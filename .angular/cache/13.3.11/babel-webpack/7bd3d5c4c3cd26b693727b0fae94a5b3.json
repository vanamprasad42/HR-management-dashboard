{"ast":null,"code":"import castPath from './_castPath.js';\nimport last from './last.js';\nimport parent from './_parent.js';\nimport toKey from './_toKey.js';\n/** Used for built-in method references. */\n\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\n\nfunction baseUnset(object, path) {\n  path = castPath(path, object); // Prevent prototype pollution, see: https://github.com/lodash/lodash/security/advisories/GHSA-xxjr-mmjv-4gpg\n\n  var index = -1,\n      length = path.length;\n\n  if (!length) {\n    return true;\n  }\n\n  var isRootPrimitive = object == null || typeof object !== 'object' && typeof object !== 'function';\n\n  while (++index < length) {\n    var key = path[index]; // skip non-string keys (e.g., Symbols, numbers)\n\n    if (typeof key !== 'string') {\n      continue;\n    } // Always block \"__proto__\" anywhere in the path if it's not expected\n\n\n    if (key === '__proto__' && !hasOwnProperty.call(object, '__proto__')) {\n      return false;\n    } // Block \"constructor.prototype\" chains\n\n\n    if (key === 'constructor' && index + 1 < length && typeof path[index + 1] === 'string' && path[index + 1] === 'prototype') {\n      // Allow ONLY when the path starts at a primitive root, e.g., _.unset(0, 'constructor.prototype.a')\n      if (isRootPrimitive && index === 0) {\n        continue;\n      }\n\n      return false;\n    }\n  }\n\n  var obj = parent(object, path);\n  return obj == null || delete obj[toKey(last(path))];\n}\n\nexport default baseUnset;","map":null,"metadata":{},"sourceType":"module"}